<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebXR Manipulate</title>
    <style>
      body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.9.1/dist/gsap.min.js"></script>
    <script type="module">
        // three.js scene and renderer
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';
        let camera, scene, renderer, xrSession = null;
        let castle, ground;
        let hitTestSource = null;
        let hitTestActive = false;
        let target = new THREE.Vector3();
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let isDragging = false;
        let dragStartMousePos = new THREE.Vector2();
        let originalScale = new THREE.Vector3();
        let planeHit = new THREE.Vector3();
        const clock = new THREE.Clock();
        let firstTouchPosition;
        let previousTouchPosition;
        let initialDistance = null;
        let gltfLoader = null;


        // set-up the scene
        function setupScene(){
          gltfLoader = new GLTFLoader();
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 8);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.7 ); // soft white light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
            directionalLight.position.set(1, 15, 3); // Position the light source
            directionalLight.castShadow = true; // Enable shadow casting
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.top = 10;
            directionalLight.target = target;
            scene.add(directionalLight);

           gltfLoader.load('sand-castle.glb', function (gltf) {
                castle = gltf.scene;
                castle.scale.set(3, 3, 3);
                castle.traverse(function (child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = false;
                    }
                });
                scene.add(castle);

                // set the position of the target to the model
                target = castle.position;
            });


            ground = new THREE.Mesh(
              new THREE.PlaneGeometry(1000, 1000),
              new THREE.ShadowMaterial({ opacity: 0.3 }),
              );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "ground";
            scene.add(ground);
        }

        // handle resizing the canvas
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // function to handle touch for the web
        function handleTouch(event) {
            const touches = event.touches;
            if (touches.length === 1) {
              mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
              mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
              raycaster.setFromCamera(mouse, camera);
              const intersects = raycaster.intersectObjects([castle]);
              if (intersects.length > 0) {
                  isDragging = true;
                  dragStartMousePos.copy(mouse);
                  originalScale.copy(castle.scale);
              }else{
                isDragging = false;
              }
            } else if (touches.length === 2){
                const touch1 = touches[0];
                const touch2 = touches[1];
                const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);

                if (initialDistance === null) {
                    initialDistance = currentDistance;
                }else{
                     const scaleFactor = currentDistance / initialDistance;
                    castle.scale.copy(originalScale).multiplyScalar(scaleFactor);
                }
                
                const currentTouch1 = new THREE.Vector2(touch1.clientX,touch1.clientY);
                const currentTouch2 = new THREE.Vector2(touch2.clientX,touch2.clientY);
                const centerCurrentTouch = new THREE.Vector2().addVectors(currentTouch1,currentTouch2).multiplyScalar(0.5);


                if(previousTouchPosition){
                   const deltaX = centerCurrentTouch.x - previousTouchPosition.x;
                    const deltaY = centerCurrentTouch.y - previousTouchPosition.y;
                    const moveX = -deltaX/1000;
                    const moveY = deltaY/1000;
                    let previousCameraAngle = 0;
                    if(moveX < 0){
                       previousCameraAngle += .05;
                    } else if(moveX > 0){
                      previousCameraAngle -= .05;
                    }
                    
                    if(moveY < 0){
                       previousCameraAngle += .05;
                    } else if(moveY > 0){
                      previousCameraAngle -= .05;
                    }
                   castle.rotation.y += previousCameraAngle
                }
                 previousTouchPosition = centerCurrentTouch.clone();

            }else{
              isDragging = false;
              initialDistance = null;
              previousTouchPosition = null;
            }

        }


        function updateTouchDrag(event) {
            if (isDragging) {
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects([ground]);
                if (intersects.length > 0) {
                    planeHit.copy(intersects[0].point)
                    castle.position.x = planeHit.x
                    castle.position.z = planeHit.z
                 }
            }
        }


       // function to handle mouse for web
        function handleMouse(event) {
           mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
           mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
           raycaster.setFromCamera(mouse, camera);
           const intersects = raycaster.intersectObjects([castle]);

           if (intersects.length > 0 && event.type == "mousedown") {
                isDragging = true;
                dragStartMousePos.copy(mouse);
                originalScale.copy(castle.scale);
            }
           
           if (event.type == 'mouseup'){
               isDragging = false;
           }
        }

        function updateMouseDrag(){
           if (isDragging) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([ground]);
                  if (intersects.length > 0) {
                      planeHit.copy(intersects[0].point)
                      castle.position.x = planeHit.x
                      castle.position.z = planeHit.z
                  }
            }
        }

        // start up the xr session
        async function startXR(){
          if (navigator.xr){
              try {
                  xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test']
                  });

                  xrSession.addEventListener('end', () => {
                       hitTestActive = false;
                  });

                  const xrRefSpace = await xrSession.requestReferenceSpace('local');
                  const xrGlLayer = new XRWebGLLayer(xrSession, renderer.getContext());

                  xrSession.updateRenderState({ baseLayer: xrGlLayer });
                  hitTestSource = await xrSession.requestHitTestSource({ space: xrRefSpace });

                  renderer.xr.enabled = true;
                  renderer.xr.setSession(xrSession);

                  let lastTime = 0;
                 renderer.setAnimationLoop((time)=>{
                     if(!hitTestActive && hitTestSource && time > lastTime + 1000){
                       lastTime = time;
                       hitTestActive = true;
                     }
                      render(time);
                   });

              } catch (e){
                 console.log("error:" + e);
              }
          }else {
              console.log("no xr support");
          }
        }

        // renderer function
        function render(time) {
           if (xrSession) {
                const xrFrame = renderer.xr.getFrame();
                if (xrFrame) {
                 if(hitTestActive){
                       const hitTestResults = xrFrame.getHitTestResults(hitTestSource);
                         if(hitTestResults.length > 0){
                           const hit = hitTestResults[0];
                            const pose = hit.getPose(renderer.xr.getReferenceSpace());
                           if(pose){
                             castle.position.x = pose.transform.position.x;
                             castle.position.y = pose.transform.position.y;
                             castle.position.z = pose.transform.position.z;

                             ground.position.copy(castle.position);
                            }

                            hitTestActive = false;
                         }
                   }
                }
            }else {
               updateMouseDrag();
              renderer.render(scene, camera);
           }
        }

        // setup and start function
        function init() {
            setupScene();
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('touchstart', handleTouch, { passive: false });
            window.addEventListener('touchmove', updateTouchDrag, { passive: false });
            window.addEventListener('mousedown', handleMouse, { passive: false });
            window.addEventListener('mouseup', handleMouse, { passive: false });
           
             if (navigator.xr){
               document.body.addEventListener('click',startXR, {once: true});
               const startButton = document.createElement('button');
                  startButton.innerHTML = 'Start XR';
                  startButton.style.position = 'absolute';
                  startButton.style.top = '10px';
                  startButton.style.left = '10px';
                  document.body.appendChild(startButton)
             }else {
               renderer.setAnimationLoop(render)
             }
        }

        init();

    </script>

</body>
</html>
